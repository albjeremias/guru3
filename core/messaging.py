import json
import re

from django.utils import timezone

from core import models, inventory_dect


def parse_incoming_wiremessage(incoming_wiremessage):
    msg_type = _WIREMESSAGE_TYPE_TABLE.get(incoming_wiremessage.type)
    if msg_type is None:
        raise MessageProcessingError("Invalid message type: '{}'".format(incoming_wiremessage.type))
    else:
        return msg_type.from_incoming_wiremessage(incoming_wiremessage)


class BaseMessage(object):
    def __init__(self, event, type, ts):
        self.data = {}
        self.event = event
        self.type = type
        self.timestamp = ts

    def makeWireMessage(self):
        wm = models.WireMessage()
        wm.event = self.event
        wm.type = self.type
        wm.data = json.dumps(self.data)
        return wm

    @classmethod
    def from_incoming_wiremessage(cls, incoming_wiremessage):
        msg = cls(incoming_wiremessage.event, incoming_wiremessage.type, incoming_wiremessage.timestamp)
        msg.data = json.loads(incoming_wiremessage.data)
        msg.parse()
        return msg

    def parse(self):
        pass


class MessageParsingError(Exception):
    pass


class MessageProcessingError(Exception):
    pass


IPEI_RE = re.compile("^\\d{5} \\d{7} [0-9*]$")
UAK_RE = re.compile("^[0-9A-F]{32}$")


class AssignHandsetMsg(BaseMessage):
    ipei = None
    extension = None
    uak = None

    def parse(self):
        self.ipei = self.data.get("ipei")
        self.extension = self.data.get("extension")
        self.uak = self.data.get("uak")

        if self.ipei is None:
            raise MessageParsingError("No IPEI provided in data")
        elif self.extension is None:
            raise MessageParsingError("No extension provided in data")
        elif self.uak is None:
            raise MessageParsingError("No UAK provided in data")

        self.uak = self.uak.upper()

        if not IPEI_RE.match(self.ipei):
            raise MessageParsingError("Invalid IPEI format.")
        elif not UAK_RE.match(self.uak):
            raise MessageParsingError("Invalid UAK format.")

    def process(self):
        try:
            extension = models.Extension.objects.get(event=self.event, extension=self.extension)
        except models.Extension.DoesNotExist:
            raise MessageProcessingError("Extension not known.")

        try:
            handset = models.DECTHandset.objects.get(ipei=self.ipei)
        except models.DECTHandset.DoesNotExist:
            handset = models.DECTHandset(ipei=self.ipei, owner=extension.owner)

        handset.uak = self.uak
        handset.save()
        inventory_dect.check_for_inventory_ipei_suggestion(extension, handset)

        #  Update extension object directly via database to avoid all triggers generated by save()
        models.Extension.objects.filter(pk=extension.pk).update(handset=handset)
        models.Extension.objects.filter(handset=handset, event=self.event).exclude(pk=extension.pk).update(handset=None)


class SyncStartMsg(BaseMessage):
    def __init__(self, event):
        super(SyncStartMsg, self).__init__(event, "SYNC_STARTED", timezone.now())


class SyncEndMsg(BaseMessage):
    def __init__(self, event):
        super(SyncEndMsg, self).__init__(event, "SYNC_ENDED", timezone.now())


class ExtensionUpdateMsg(BaseMessage):
    def __init__(self, extension, no_forwards=False):
        super(ExtensionUpdateMsg, self).__init__(extension.event, "UPDATE_EXTENSION",
                                                 extension.lastChanged)
        self.data["number"] = extension.extension
        self.data["name"] = extension.name
        self.data["location"] = extension.location
        self.data["announcement_lang"] = extension.announcement_lang
        if extension.ringback_tone is not None:
            self.data["ringback_tone"] = extension.ringback_tone.sha512
        else:
            self.data["ringback_tone"] = ""
        self.data["call_waiting"] = extension.call_waiting
        self.data["allow_dialout"] = extension.allow_dialout
        if extension.pk is not None and extension.type != "GROUP" and len(extension.group_members.all()) > 0:
            self.data["has_multiring"] = True

        if not no_forwards and extension.forward_extension is not None:
            self.data["forward_extension"] = extension.forward_extension.extension
            self.data["forward_mode"] = extension.forward_mode
            self.data["forward_delay"] = extension.forward_delay

        if extension.sip_trunk:
            self.data["trunk"] = True


class ExtensionDeleteMsg(BaseMessage):
    def __init__(self, extension, number):
        super(ExtensionDeleteMsg, self).__init__(extension.event, "DELETE_EXTENSION", timezone.now())
        self.data["number"] = number


class SIPUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super(SIPUpdateMsg, self).__init__(extension, no_forwards)
        self.data["type"] = "SIP"
        self.data["password"] = extension.sipPassword
        self.data["isPremium"] = extension.isPremium


class DECTUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super(DECTUpdateMsg, self).__init__(extension, no_forwards)
        self.data["type"] = "DECT"
        self.data["token"] = extension.registerToken
        self.data["useEncryption"] = extension.useEncryption
        self.data["displayModus"] = extension.displayModus
        if extension.handset is not None:
            dect_handset = {
                "ipei": extension.handset.ipei,
                "uak": extension.handset.uak
            }
            self.data["dect"] = dect_handset


class GSMUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super(GSMUpdateMsg, self).__init__(extension, no_forwards)
        self.data["type"] = "GSM"
        self.data["token"] = extension.registerToken
        self.data["use2G"] = extension.twoGOptIn
        self.data["use3G"] = extension.threeGOptIn
        self.data["use4G"] = extension.fourGOptIn


class AnnouncementUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super().__init__(extension, no_forwards)
        self.data["type"] = "ANNOUNCEMENT"
        self.data["announcement_audio"] = extension.announcement_audio.sha512 if extension.announcement_audio else ""


class ApplicationUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super().__init__(extension, no_forwards)
        self.data["type"] = "APP"
        self.data["direct_routing_target"] = extension.direct_routing_target


class GroupUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super(GroupUpdateMsg, self).__init__(extension, no_forwards)
        self.data["type"] = "GROUP"
        self.data["short_name"] = extension.group_shortcode


class TypeOnlyUpdateMsg(ExtensionUpdateMsg):
    def __init__(self, extension, no_forwards=False):
        super().__init__(extension, no_forwards)
        self.data["type"] = extension.type


class GroupInviteUpdateMsg(BaseMessage):
    def __init__(self, callgroup):
        invites = models.CallGroupInvite.objects.filter(group=callgroup, accepted=True)
        event = callgroup.event
        super().__init__(event, "UPDATE_CALLGROUP", timezone.now())
        self.data["name"] = callgroup.name
        self.data["number"] = callgroup.extension
        self.data["extensions"] = [{
            "extension": invite.extension.extension,
            "active": invite.active,
            "delay": invite.delay_s,
        } for invite in invites]


class RenameExtensionMsg(BaseMessage):
    def __init__(self, old_extension: str, extension: 'models.Extension'):
        super().__init__(extension.event, "RENAME_EXTENSION", timezone.now())
        self.data["old_extension"] = old_extension
        self.data["new_extension"] = extension.extension


class UnsubscribeDeviceMsg(BaseMessage):
    def __init__(self, extension: 'models.Extension'):
        super().__init__(extension.event, "UNSUBSCRIBE_DEVICE", timezone.now())
        self.data["extension"] = extension.extension


class CallExtensionMsg(BaseMessage):
    def __init__(self, caller_number: str, caller_name: str, called: 'models.Extension', audio_hash: str):
        super().__init__(called.event, "CALL_EXTENSION", timezone.now())
        self.data["number"] = called.extension
        self.data["caller_number"] = caller_number
        self.data["caller_name"] = caller_name
        self.data["announcement_audio"] = audio_hash


msg_factory_table = {
    "SIP": SIPUpdateMsg,
    "DECT": DECTUpdateMsg,
    "GSM": GSMUpdateMsg,
    "GROUP": GroupUpdateMsg,
    "SPECIAL": TypeOnlyUpdateMsg,
    "APP": ApplicationUpdateMsg,
    "ANNOUNCEMENT": AnnouncementUpdateMsg,
}


_WIREMESSAGE_TYPE_TABLE = {
    "ASSIGN_HANDSET": AssignHandsetMsg,
}


def makeExtensionUpdateMessage(extension, no_forwards=False):
    msgClass = msg_factory_table.get(extension.type)
    return msgClass(extension, no_forwards).makeWireMessage()


def makeExtensionDeleteMessage(extension, number):
    return ExtensionDeleteMsg(extension, number).makeWireMessage()


def makeGroupUpdateMessage(callgroup):
    return GroupInviteUpdateMsg(callgroup).makeWireMessage()
